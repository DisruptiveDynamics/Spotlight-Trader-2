You are a senior reliability engineer auditing the repo DisruptiveDynamics/Spotlight-Trader-2. Produce a ruthless, actionable diagnosis and grades for all critical subsystems, with artifacts I can paste back to my GitHub Copilot for a deep dive.

Guardrails
- Do NOT expose secrets. If you must display keys, mask to last 4 chars.
- Do NOT push commits unless I explicitly say “apply fixes.” Default is read/diagnose only.
- Small, auditable steps. If you change runtime config, document it in VERIFY.md.
- If something is ambiguous, pick a sensible default and keep moving.

Goals
- Identify exactly why minute bars/charts misbehave while ticks flow.
- Identify why voice coach disconnects/loops.
- Confirm or refute the “OnDemand replay” approach and how to adopt it cleanly.
- Grade each subsystem with clear reasons and evidence.
- Output precise, copy-pasteable next steps with acceptance criteria.

Baseline (print this first, ≤10 lines)
- Node, pnpm versions; current branch and HEAD commit SHA.
- Server bind host/port; client dev server port.
- SSE endpoint path(s); WebSocket endpoints (voice).
- History endpoint(s) you call for charts.
- Whether mock tick generator is enabled; any feature flags impacting data path.
- Vite HMR status (enabled/disabled).

Repo inventory and static analysis (produce findings with file:line references)
- List all Bar/Microbar/MinuteBar type definitions and where they’re used.
- Find all places that compute or assign bar seq (search for “seq”, “Math.floor(…/60000)”).
- Find all SSE emitters/listeners: eventBus.emit('bar:new:*'), 'microbar:*', 'tick:*'; where SSE writes happen.
- Find all history fetchers: Polygon aggs usage (v2/v3), URL builders, date vs ISO ranges, error handling.
- Find any require() in ESM code paths; list files.
- Find any duplicate ring buffer implementations (e.g., ring.ts, ring.ts.bak) or bespoke caches; list where used.
- Find any conversions ms↔seconds when writing to chart; list call sites.
- Voice: locate WebSocket client(s). Check ws.binaryType, onmessage branching for ArrayBuffer vs string, ping/pong heartbeat, bufferedAmount backpressure guard. List gaps.
- Auth/cookies: where JWT cookie is set; SameSite/Secure/maxAge; iPad/Safari considerations; Vite HMR behavior.
- CSP/connect-src: ensure polygon socket and our WS/SSE origins are allowed.

Runtime diagnostics (execute; capture commands + outputs)
- pnpm install; pnpm -r typecheck; pnpm -r lint; pnpm -r test — note errors/warnings.
- Start server; print listening URL. Hit:
  - curl -sfv http://localhost:8080/api/healthz
  - curl -sfv http://localhost:8080/api/metrics (if present)
  - curl -sfv "http://localhost:8080/api/history?symbol=SPY&timeframe=1m&limit=50"
- Exercise SSE:
  - Open SSE route you find (e.g., /api/stream/market or equivalent) with curl -N and confirm heartbeats (lines starting with “:”).
  - Capture first 10 “bar” events and show seq, bar_start, bar_end, ohlcv.
- Polygon API probe:
  - Print the exact constructed URL(s) and the raw HTTP status + first 300 chars of the response for an aggs request you perform (mask apiKey).
  - If results are empty, show the full request window in ISO and in America/New_York local time.
- Bar finalize tracing:
  - Enable debug logs for bar finalization (if present). Otherwise temporarily add logging and show 10 consecutive finalized bars (seq, start/end ISO, ohlcv, volume).
- Voice WS probe:
  - Connect the voice client once; confirm ws.binaryType, show onmessage types observed (string vs ArrayBuffer), confirm ping/pong flow; note any backpressure warnings.
- Safari/iPad signal (if possible in this environment):
  - Confirm SameSite=None; Secure on cookies; note HMR reloads correlating with “auth invalid”.

Grading rubric (produce a single YAML with grades 0–10 per category + reasons)
- data_pipeline_bars (seq/time alignment, DST/session boundaries, finalization reliability)
- history_fetch (Polygon requests, ISO vs date-only, error logging, rate-limit handling)
- sse_resilience (heartbeats, backpressure, reconnects, dedupe)
- client_chart_integration (ms→seconds conversion, update throttling, gap-fill correctness)
- voice_ws (binary handling, heartbeat, backpressure, reconnection)
- auth_cookies (SameSite/Secure/maxAge; mobile Safari behavior)
- dev_runtime (Vite HMR config, proxy, ports)
- observability (metrics, admin snapshot, diag endpoints, structured logs)
- code_health (duplicate types/buffers, ESM/CJS consistency, env validation)

Deliverables (create these files; paste full contents back here)
1) DIAGNOSIS.md
- Executive summary with root causes (1–3 bullets each for bars/charts and voice).
- Evidence: code refs (file:line), logs, curl outputs.
- Repro steps (commands + URLs).
- Risk notes.

2) GRADES.yaml
- The rubric above with numeric grade per category and 1–3 bullet reasons each.

3) BARS_SEQ_AUDIT.md
- Table of 20 consecutive bars (seq, start ISO, end ISO, ohlcv, volume).
- Explain seq policy you observed (incrementing vs time-derived).
- Note any ms↔seconds confusion at chart boundaries.

4) POLYGON_REQUEST_LOGS.txt
- For at least 2 symbols (SPY, QQQ), show the full aggs request URLs (mask key), HTTP status, and first 300 chars of the response for the same time window used by /api/history.

5) VOICE_WS_AUDIT.md
- Observed ws.binaryType, onmessage branch behavior, presence of ping/pong, backpressure logs, and any JSON parse of Blob errors.

6) VERIFY.md
- End-to-end checklist to validate fixes when applied (bars seed/resync, gap-fill, voice stable, metrics OK), with commands and expected outputs.

7) OPTIONAL if quick to add (don’t block on this):
- DIAG_ROUTE_NOTES.md — If you add a temporary /api/diag route, document its fields (lastSeq per symbol, bars1m size, ring buffer size).

What to answer back in chat (must paste)
- The full contents of DIAGNOSIS.md, GRADES.yaml, BARS_SEQ_AUDIT.md, POLYGON_REQUEST_LOGS.txt, VOICE_WS_AUDIT.md, and VERIFY.md.
- Explicit SSE path(s) and example “bar” event payloads with seq values.
- A one-paragraph recommendation on adopting “OnDemand replay” to replace mocks, based on what you observed.

Acceptance
- I should be able to read the artifacts and immediately see:
  - Whether seq is time-derived and consistent across server/client/history.
  - Whether Polygon requests are formed correctly and why they sometimes return empty.
  - Whether voice WS handles binary and heartbeat correctly.
  - A trustworthy grade per subsystem and a short, prioritized next-steps list.

If you get blocked
- State the blocker, show the command/output leading to it, and propose 2 ways to proceed (e.g., add a small log, or temporarily adjust config).